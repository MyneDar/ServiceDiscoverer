// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"servicediscoverer/ent/providerendpoint"
	"servicediscoverer/ent/providerregisterdata"
	"strings"

	"entgo.io/ent/dialect/sql"
)

// ProviderEndpoint is the model entity for the ProviderEndpoint schema.
type ProviderEndpoint struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"-"`
	// Name holds the value of the "name" field.
	Name string `json:"name,omitempty"`
	// Path holds the value of the "path" field.
	Path string `json:"path,omitempty"`
	// Type holds the value of the "type" field.
	Type string `json:"type,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the ProviderEndpointQuery when eager-loading is set.
	Edges                            ProviderEndpointEdges `json:"data"`
	provider_register_data_endpoints *int
}

// ProviderEndpointEdges holds the relations/edges for other nodes in the graph.
type ProviderEndpointEdges struct {
	// RequiredData holds the value of the required_data edge.
	RequiredData []*EndpointData `json:"required_data,omitempty"`
	// ProvidedData holds the value of the provided_data edge.
	ProvidedData []*EndpointData `json:"provided_data,omitempty"`
	// Provider holds the value of the provider edge.
	Provider *ProviderRegisterData `json:"provider,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [3]bool
}

// RequiredDataOrErr returns the RequiredData value or an error if the edge
// was not loaded in eager-loading.
func (e ProviderEndpointEdges) RequiredDataOrErr() ([]*EndpointData, error) {
	if e.loadedTypes[0] {
		return e.RequiredData, nil
	}
	return nil, &NotLoadedError{edge: "required_data"}
}

// ProvidedDataOrErr returns the ProvidedData value or an error if the edge
// was not loaded in eager-loading.
func (e ProviderEndpointEdges) ProvidedDataOrErr() ([]*EndpointData, error) {
	if e.loadedTypes[1] {
		return e.ProvidedData, nil
	}
	return nil, &NotLoadedError{edge: "provided_data"}
}

// ProviderOrErr returns the Provider value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e ProviderEndpointEdges) ProviderOrErr() (*ProviderRegisterData, error) {
	if e.loadedTypes[2] {
		if e.Provider == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: providerregisterdata.Label}
		}
		return e.Provider, nil
	}
	return nil, &NotLoadedError{edge: "provider"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*ProviderEndpoint) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case providerendpoint.FieldID:
			values[i] = new(sql.NullInt64)
		case providerendpoint.FieldName, providerendpoint.FieldPath, providerendpoint.FieldType:
			values[i] = new(sql.NullString)
		case providerendpoint.ForeignKeys[0]: // provider_register_data_endpoints
			values[i] = new(sql.NullInt64)
		default:
			return nil, fmt.Errorf("unexpected column %q for type ProviderEndpoint", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the ProviderEndpoint fields.
func (pe *ProviderEndpoint) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case providerendpoint.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			pe.ID = int(value.Int64)
		case providerendpoint.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				pe.Name = value.String
			}
		case providerendpoint.FieldPath:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field path", values[i])
			} else if value.Valid {
				pe.Path = value.String
			}
		case providerendpoint.FieldType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field type", values[i])
			} else if value.Valid {
				pe.Type = value.String
			}
		case providerendpoint.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for edge-field provider_register_data_endpoints", value)
			} else if value.Valid {
				pe.provider_register_data_endpoints = new(int)
				*pe.provider_register_data_endpoints = int(value.Int64)
			}
		}
	}
	return nil
}

// QueryRequiredData queries the "required_data" edge of the ProviderEndpoint entity.
func (pe *ProviderEndpoint) QueryRequiredData() *EndpointDataQuery {
	return (&ProviderEndpointClient{config: pe.config}).QueryRequiredData(pe)
}

// QueryProvidedData queries the "provided_data" edge of the ProviderEndpoint entity.
func (pe *ProviderEndpoint) QueryProvidedData() *EndpointDataQuery {
	return (&ProviderEndpointClient{config: pe.config}).QueryProvidedData(pe)
}

// QueryProvider queries the "provider" edge of the ProviderEndpoint entity.
func (pe *ProviderEndpoint) QueryProvider() *ProviderRegisterDataQuery {
	return (&ProviderEndpointClient{config: pe.config}).QueryProvider(pe)
}

// Update returns a builder for updating this ProviderEndpoint.
// Note that you need to call ProviderEndpoint.Unwrap() before calling this method if this ProviderEndpoint
// was returned from a transaction, and the transaction was committed or rolled back.
func (pe *ProviderEndpoint) Update() *ProviderEndpointUpdateOne {
	return (&ProviderEndpointClient{config: pe.config}).UpdateOne(pe)
}

// Unwrap unwraps the ProviderEndpoint entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (pe *ProviderEndpoint) Unwrap() *ProviderEndpoint {
	_tx, ok := pe.config.driver.(*txDriver)
	if !ok {
		panic("ent: ProviderEndpoint is not a transactional entity")
	}
	pe.config.driver = _tx.drv
	return pe
}

// String implements the fmt.Stringer.
func (pe *ProviderEndpoint) String() string {
	var builder strings.Builder
	builder.WriteString("ProviderEndpoint(")
	builder.WriteString(fmt.Sprintf("id=%v, ", pe.ID))
	builder.WriteString("name=")
	builder.WriteString(pe.Name)
	builder.WriteString(", ")
	builder.WriteString("path=")
	builder.WriteString(pe.Path)
	builder.WriteString(", ")
	builder.WriteString("type=")
	builder.WriteString(pe.Type)
	builder.WriteByte(')')
	return builder.String()
}

// ProviderEndpoints is a parsable slice of ProviderEndpoint.
type ProviderEndpoints []*ProviderEndpoint

func (pe ProviderEndpoints) config(cfg config) {
	for _i := range pe {
		pe[_i].config = cfg
	}
}
